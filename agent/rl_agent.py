from . import BaseAgent
from common.registry import Registry
import gym
from generator import LaneVehicleGenerator, IntersectionPhaseGenerator, IntersectionVehicleGenerator
import random
import numpy as np


@Registry.register_model('rl')
class RLAgent(BaseAgent):
    '''
    RLAgent Class is mainly used for creating a rl-based agent and base methods.
    '''
    def __init__(self, world, intersection_ids):
        super().__init__(world)
        self.graph = Registry.mapping['world_mapping']['graph_setting'].graph
        # self.device = torch.device("cpu")
        # print('self.device', self.device)
        # print('训练一个智能体共享参数')
        # print(Registry.mapping['world_mapping']['graph_setting'])
        self.world = world
        self.sub_agents = len(self.world.intersections)  # 3
        # TODO: support dynamic graph later  边的信息
        # self.edge_idx = torch.tensor(self.graph['sparse_adj'].T, dtype=torch.long).to(self.device)  # source -> target

        #  model parameters
        self.phase = Registry.mapping['model_mapping']['setting'].param['phase']
        self.one_hot = Registry.mapping['model_mapping']['setting'].param['one_hot']
        self.model_dict = Registry.mapping['model_mapping']['setting'].param
        self.id = intersection_ids
        self.inter_obj = self.world.id2intersection[self.id]
        self.action_space = gym.spaces.Discrete(len(self.inter_obj.phases))
        self.ob_generator = LaneVehicleGenerator(self.world, self.inter_obj,
                                                 ["lane_count"], in_only=True, average=None)
        self.phase_generator = IntersectionPhaseGenerator(self.world, self.inter_obj,
                                                          ['phase'], targets=['cur_phase'], negative=False)
        self.reward_generator = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_waiting_count"], in_only=True, average="all",
                                                     negative=True)
        self.queue = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_waiting_count"], in_only=True,
                                                     negative=False)
        self.delay = LaneVehicleGenerator(self.world, self.inter_obj,
                                                     ["lane_delay"], in_only=True, average="all",
                                                     negative=False)
    def get_ob(self):
        '''
        get_ob
        Get observation from environment.

        :param: None
        :return: observation generated by ob_generator
        '''
        x_obs = []  # sub_agents * lane_nums,
        for i in range(len(self.ob_generator)):
            x_obs.append((self.ob_generator[i][1].generate()) / self.vehicle_max)
        # construct edge information.
        length = set([len(i) for i in x_obs])
        if len(length) == 1:  # each intersections may has  different lane nums
            x_obs = np.array(x_obs, dtype=np.float32)
        else:
            x_obs = [np.expand_dims(x, axis=0) for x in x_obs]
        return x_obs

    def get_phase(self):
        '''
        get_phase
        Get current phase of intersection(s) from environment.

        :param: None
        :return: current phase generated by phase_generator
        '''
        phase = []  # sub_agents
        for i in range(len(self.phase_generator)):
            phase.append((self.phase_generator[i][1].generate()))  # [[0],[0],[0]]
        phase = (np.concatenate(phase)).astype(np.int8)
        # phase = np.concatenate(phase, dtype=np.int8)
        return phase  # [0 0 0]

    def get_reward(self):
        '''
        get_reward
        Get reward from environment.

        :param: None
        :return: reward generated by reward_generator
        '''
        rewards = []  # sub_agents
        for i in range(len(self.reward_generator)):
            rewards.append(self.reward_generator[i][1].generate())
        rewards = np.squeeze(np.array(rewards)) * 12
        return rewards

    def get_action(self):
        '''
        get_action
        Generate action.

        :param: None
        :return: action generated by sample function
        '''
        return self.action_space.sample()
    
    def sample(self):
        '''
        sample
        Sample action randomly.

        :param: None
        :return: action generated randomly.
        '''
        return random.randint(0,self.action_space.n-1)

    def get_queue(self):
        '''
        get_queue
        Get queue length of intersection.

        :param: None
        :return: total queue length
        '''
        queue = []
        for i in range(len(self.queue)):
            queue.append((self.queue[i][1].generate()))
        tmp_queue = np.squeeze(np.array(queue))
        queue = np.sum(tmp_queue, axis=1 if len(tmp_queue.shape) == 2 else 0)
        return queue

    def get_delay(self):
        '''
        get_delay
        Get delay of intersection.

        :param: None
        :return: total delay
        '''
        delay = []
        for i in range(len(self.delay)):
            delay.append((self.delay[i][1].generate()))
        delay = np.squeeze(np.array(delay))
        return delay  # [intersections,]
    
    """
    def choose(self, **kwargs):
        raise NotImplementedError
    """

